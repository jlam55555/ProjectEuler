<!DOCTYPE html>
<html>
  <body onload="links('Lattice Paths','15','paths')">
    <script id="script">// javascript
var t1 = performance.now();
var numRows = 20;
function factorial(num) {
  for(var i = num-1, result = num; i > 0; i--)
    result *= i;
  return result;
};
var paths = Math.floor(factorial(2*numRows) / Math.pow(factorial(numRows), 2));
var t2 = performance.now();
</script>
    ~Calculates the number of paths. This is using a simple formula that I found.~
    #<code>Math.floor()</code> used because answer is not precise because of floating-point precision.#
    #My old answer was a brute-force method that only worked for small numbers. Here it is:<pre><code>// javascript
var maxX = 8, maxY = 8, count = 0, path = function(x, y) {
  if(x == maxX && y == maxY) {
    count++;
    return;
  }
  if(x+1 <= maxX)
    path(x+1, y);
  if(y+1 <= maxY)
    path(x, y+1);
};
path(0, 0);</code></pre>I actually set it to inputs 1-8 because 20 took too long, noticed the pattern in jumps, and came up with this final math problem that got me the real answer: <code>2*(3/1)*(10/3)*(7/2)*(18/5)*(11/3)*(26/7)*(15/4)*(34/9)*(19/5)*(42/11)*(23/6)*(50/13)*(27/7)*(58/15)*(31/8)*(66/17)*(35/9)*(74/19)*(39/10)</code>. Really inefficient, but it works!#
    <script src="res/euler.js"></script>
  </body>
</html>
